import java.nio.charset.Charset

import scalajsbundler.util.JSON

enablePlugins(ScalaJSBundlerPlugin)

name := "mobile-client"

scalacOptions += "-P:scalajs:sjsDefinedByDefault"

webpackBundlingMode := BundlingMode.LibraryOnly()

emitSourceMaps := true
webpackEmitSourceMaps := true

npmDevDependencies in Compile += "react-native-scripts" -> "1.8.1"
npmDevDependencies in Compile += "jest-expo" -> "23.0.0"
npmDevDependencies in Compile += "react-test-renderer" -> "16.0.0"

additionalNpmConfig in Compile += "name" -> JSON.str(name.value)
additionalNpmConfig in Compile += "main" -> JSON.str("./node_modules/react-native-scripts/build/bin/crna-entry.js")
additionalNpmConfig in Compile += "scripts" -> JSON.objStr(Seq(
  "start" -> "react-native-scripts start",
  "eject" -> "react-native-scripts eject",
  "android" -> "react-native-scripts android",
  "ios" -> "react-native-scripts ios",
  "test" -> "node node_modules/jest/bin/jest.js --watch",
))
additionalNpmConfig in Compile += "jest" -> JSON.objStr(Seq(
  "preset" -> "jest-expo",
))

npmDependencies in Compile += "expo" -> "^23.0.4"
npmDependencies in Compile += "react" -> "16.0.0"
npmDependencies in Compile += "react-native" -> "0.50.3"

libraryDependencies ++= Seq(
  "org.scala-js"  %%% "scalajs-dom"      % "0.9.4",
)

libraryDependencies += "me.shadaj" %%% "slinky-web" % "0.2.0"

addCompilerPlugin("org.scalameta" % "paradise" % "3.0.0-M10" cross CrossVersion.full)


lazy val targetDir = settingKey[File]("node app base")

targetDir := (crossTarget in npmUpdate).value / "scalajs-bundler" / "main"

lazy val launcherFile = settingKey[File]("generated launcher")

launcherFile := targetDir.value / "App.js"

lazy val appConfigFile = settingKey[File]("expo app config file")

appConfigFile := targetDir.value / "app.json"

lazy val expo = taskKey[Unit]("compile and launch Expo")

lazy val expoStart = taskKey[Unit]("launch Expo")

lazy val expoAndroid = taskKey[Unit]("launch Expo and attempt to launch/connect to an Android emulator")

lazy val expoIOS = taskKey[Unit]("launch Expo and attempt to launch/connect to an IOS emulator")

lazy val createLaunchersEtc = taskKey[Unit]("create JS launchers for the compiled Scala.js code")

lazy val cleanupUnused = taskKey[Unit]("cleanup unused entrypoints generated by scalajs-bundler")

lazy val prepareApp = taskKey[Unit]("prepare and compile the React Native project")

artifactPath in (Compile, fastOptJS) := ((crossTarget in (Compile, fastOptJS)).value / (name.value + ".js"))
artifactPath in (Compile, fullOptJS) := (artifactPath in (Compile, fastOptJS)).value

prepareApp in Compile := Def.sequential(
  webpack in (Compile, fastOptJS),
  createLaunchersEtc in Compile,
  cleanupUnused in Compile
).value

createLaunchersEtc in Compile := {
  val log = streams.value.log

  // Create the launcher
  val file = launcherFile.value
  val code = s"""
    |'use strict';
    |require('./${name.value}-library');
    |var app = require('./${name.value}');
    |export default app.App;
  """.stripMargin.trim

  log.info(s"Creating launcher ${file}")
  IO.write(file, code, Charset.forName("UTF-8"))

  val appCfgFile = appConfigFile.value
  val appCfg = s"""
    |{
    |  "expo": {
    |    "sdkVersion": "23.0.0"
    |  }
    |}
  """.stripMargin.trim
  log.info(s"Creating app config file ${appCfgFile}")
  IO.write(appCfgFile, appCfg, Charset.forName("UTF-8"))
}

cleanupUnused in Compile := {
  IO.delete(targetDir.value / (name.value + "-entrypoint.js"))
  IO.delete(targetDir.value / (name.value + "-loader.js"))
}

expoStart := {
  launchExpo(targetDir.value, streams.value.log, "start")
}

expo in Compile := {
  val x = (prepareApp in Compile).value
  launchExpo(targetDir.value, streams.value.log, "start")
}

expoAndroid in Compile := {
  val x = (prepareApp in Compile).value
  launchExpo(targetDir.value, streams.value.log, "run-script", "android")
}

expoIOS in Compile := {
  val x = (prepareApp in Compile).value
  launchExpo(targetDir.value, streams.value.log, "run-script", "ios")
}

def launchExpo(targetDir: File, log: Logger, cmd: String*) = {
  scalajsbundler.Npm.run(cmd: _*)(targetDir, log)
}


